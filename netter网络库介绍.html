<!DOCTYPE html><html><head><title>netter网络库介绍</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style></style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-1864" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-2097" class="wmd-preview-section preview-content">

<h3 id="netter网络库介绍">netter网络库介绍</h3></div><div id="wmd-preview-section-1868" class="wmd-preview-section preview-content">

<h4 id="1-多线程reactor模型">1. 多线程Reactor模型</h4>

<p>具体可以参考Doug Lea的 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank">Scalable IO in Java</a></p>

<ul><li>主线程是一个EventLoop，用于监听客户端的连接。</li>
<li>一个IO线程池，每个线程是一个EventLoop，所有连接的IO操作都在IO线程里面进行，两种情况会把连接注册到IO线程的Eventloop: 1) 主线程的Eventloop接受一个客户端连接，2)在任一一个线程，客户端通过Connect()接口连接服务端后。注册之后，对一个连接来说，所有的事件触发都在一个IO线程里面完成, 但不同连接可能在不同的IO线程，所以如果要修改一些全局的数据结构，需要加线程锁。</li>
<li>一个Work线程池，对于耗时的处理请求，应该生成一个Task，放到其中的一个Work线程执行， 执行完后，把回复包放回IO线程发送给客户端。</li>
</ul>

</div><div id="wmd-preview-section-1869" class="wmd-preview-section preview-content">

<h4 id="2-接口使用说明">2. 接口使用说明</h4>

</div><div id="wmd-preview-section-1870" class="wmd-preview-section preview-content">

<h5 id="1-eventlooph">1) event_loop.h</h5>

</div><div id="wmd-preview-section-1871" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_thread_event_loops</span><span class="hljs-params">(<span class="hljs-keyword">int</span> io_thread_num)</span></span>;<br><br><span class="hljs-function">EventLoop* <span class="hljs-title">get_main_event_loop</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">EventLoop* <span class="hljs-title">get_io_event_loop</span><span class="hljs-params">(net_handle_t handle)</span></span>;<br><br><span class="hljs-comment">// class EventLoop</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddTimer</span><span class="hljs-params">(callback_t callback, <span class="hljs-keyword">void</span>* user_data, <br>            uint64_t interval)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">(uint32_t wait_timeout = <span class="hljs-number">100</span>)</span></span>;    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span>；</span><br></code></pre>

<p>说明： <br>
init_thread_event_loops()用来初始化主线程和IO线程的Eventloop <br>
io_thread_num = 0表示没有独立的IO线程，所有IO都在主线程处理 <br>
否则，启动io_thread_num个线程的线程池来处理IO事件</p>

<p>get_main_event_loop()用来获取主线程的Eventloop <br>
get_io_event_loop()用来获取handle所在的IO线程的Eventloop，一般在base库内使用</p>

<p>每个连接对象的OnTimer()都是在各自的IO线程里面触发，应用不需要关心。 <br>
如果要注册其他的Timer，可以在主线程的Eventloop里面用AddTimer接口 <br>
注册定时器，定时器的精度是Start()接口的wait_timeout，默认是100ms</p>

<p>Start() 启动Eventloop，应用只需要启动主线程的Eventloop，IO线程的Eventloop由IO线程池自己启动，应用一般在main函数的最后调用一下 <br>
get_main_event_loop()-&gt;Start();</p>

<p>Stop() 停止某个IO线程的Eventloop，测试时用一下，没卵用</p>

</div><div id="wmd-preview-section-1872" class="wmd-preview-section preview-content">

<h5 id="2-baselistenerh">2) base_listener.h</h5>

</div><div id="wmd-preview-section-1873" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">start_listen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; server_ip, uint16_t port)</span></span><br></code></pre>

<p>说明:  <br>
启动监听到server_ip:port的服务，生成客户端连接的对象用模板T表示 <br>
比如用 start_listen&lt; HttpConn &gt;(“127.0.0.1”, 8888);  <br>
启动一个监听到127.0.0.1:8888的http服务，用HttpConn来生成客户端连接对象</p>

</div><div id="wmd-preview-section-1874" class="wmd-preview-section preview-content">

<h5 id="3-baseconnh">3) base_conn.h</h5>

</div><div id="wmd-preview-section-1875" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_thread_base_conn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> io_thread_num)</span></span>;<br><br><span class="hljs-comment">// class BaseConn</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> net_handle_t <span class="hljs-title">Connect</span><span class="hljs-params">(<br>            <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; server_ip, <br>            uint16_t server_port)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConnect</span><span class="hljs-params">(BaseSocket* base_socket)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnConfirm</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnRead</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnWrite</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTimer</span><span class="hljs-params">(uint64_t curr_tick)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandlePkt</span><span class="hljs-params">(CPktBase* pPkt)</span> </span>{}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SendPkt</span><span class="hljs-params">(CPktBase* pkt)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">int</span> len)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">SendPkt</span><span class="hljs-params">(net_handle_t handle, CPktBase* pkt)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CloseHandle</span><span class="hljs-params">(net_handle_t handle)</span></span>; <br></code></pre>

<p>说明: <br>
init_thread_base_conn()用来初始化BaseConn的IO线程池管理， <br>
每一个IO线程有一个handle-&gt;BaseConn的映射表，还有每个IO线程需要发送的数据包队列</p>

<p>应用的连接对象需要继承BaseConn <br>
OnConnect()表示客户端刚连接进来，如果应用override OnConnect()方法， <br>
那么在OnConnect()里面需要调用BaseConn::OnConnect()，用来处理BaseConn里面的一些成员初始化和连接对象添加工作</p>

<p>OnConfirm()表示成功连接服务端，如果应用override OnConfirm()方法， <br>
那么在OnConform()里面需要调用BaseConn::OnConform()，用来处理BaseConn里面的一些成员初始化和连接对象添加工作</p>

<p>OnRead()表示可读事件，如果处理CPktBase类型的数据包，应用不用关心， <br>
应用只需要override HandlePkt()方法</p>

<p>OnWrite()表示可写事件，应用不用关心</p>

<p>OnClose()表示连接关闭(对端关闭连接或连接服务器失败), 如果应用override OnClose()方法，那么在OnClose()里面需要调用BaseConn::OnClose()，用来处理BaseConn里面的一些连接对象清除工作</p>

<p>OnTimer()表示定时器事件，默认1秒触发一次</p>

<p>Connect()连接服务器的方法，如果要override该方法，应用需要先调用 <br>
BaseConn::Connect()来做一些初始化</p>

<p>Close() 关闭连接，删除连接对象, 在OnClose()和OnTimer()里面会调用。 如果应用override该方法，需要在方法里面先调用BaseConn::Close()，用来处理BaseConn里面的一些清除工作</p>

<p>SendPkt(CPktBase* pkt)用于BaseConn所在的IO线程发送数据包，应用需要自己删除pkt，因为pkt可能是栈上分配的数据包</p>

<p>int SendPkt(net_handle_t handle, CPktBase* pkt)用于非BaseConn所在的IO线程发送数据包，比如Work线程发送数据包。pkt必须是在堆上分配的数据包，由网络IO线程发送完数据包后，再进行删除，应用不能删除pkt，不然会产生多次delete而造成crash。</p>

<p>CloseHandle()用于其他线程关闭某个handle的连接，用handle处理多线程中的连接对象，可以避免因为多线程操作同一个对象指针而导致的crash问题。</p>

</div><div id="wmd-preview-section-1876" class="wmd-preview-section preview-content">

<h5 id="4-httpconnh">4)  http_conn.h</h5>

</div><div id="wmd-preview-section-1877" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_thread_http_conn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> io_thread_num)</span></span>;<br></code></pre>

</div><div id="wmd-preview-section-1878" class="wmd-preview-section preview-content">

<h5 id="5-httphandlermaph">5) http_handler_map.h</h5>

</div><div id="wmd-preview-section-1879" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-comment">// class HttpHandlerMap</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddHandler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; url, http_handler_t handler)</span></span>;<br></code></pre>

<p>说明: <br>
 使用HTTP时，只要在初始化时调用init_thread_http_conn()， <br>
然后在HttpHandlerMap单实例里面通过AddHandler()方法添加处理url的 <br>
handler就可以了</p>

</div><div id="wmd-preview-section-1880" class="wmd-preview-section preview-content">

<h5 id="6simplelogh">6）simple_log.h</h5>

</div><div id="wmd-preview-section-1881" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_simple_log</span><span class="hljs-params">(LogLevel level, <span class="hljs-built_in">string</span> path)</span></span>;<br>log_message(level, fmt, ...)<br></code></pre>

<p>说明：不解释</p>

</div><div id="wmd-preview-section-1882" class="wmd-preview-section preview-content">

<h5 id="7-threadpoolh">7) thread_pool.h</h5>

</div><div id="wmd-preview-section-1883" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-c++ hljs cpp"><span class="hljs-comment">//class Task;</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//class ThreadPool;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Init</span><span class="hljs-params">(uint32_t thread_num)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddTask</span><span class="hljs-params">(Task* pTask)</span></span>;<br></code></pre>

<p>说明： <br>
用Init()初始化一个固定数量的线程池 <br>
定义Task的子类，override Task的run()方法执行具体任务 <br>
然后用AddTask()方法把具体的Task扔到工作线程池执行就可以了</p>

</div><div id="wmd-preview-section-2181" class="wmd-preview-section preview-content">

<h4 id="3-demo">3. Demo</h4>

<p>src/test目录下有一个服务器，阻塞式客户端，非阻塞式客户端3个例子</p></div><div id="wmd-preview-section-2248" class="wmd-preview-section preview-content">

<h4 id="4-c语言标准">4. C++语言标准</h4>

<p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank">C++11</a></p>

<ul><li>用C++11的标准库unordered_map来替换原来非标准的hash_map</li>
<li>int2string()用std::to_string()替换</li>
<li>atomic原子操作</li>
<li>auto类型推导简化迭代器的初始化</li>
<li>initializer_list</li>
<li>…</li>
</ul></div><div id="wmd-preview-section-2271" class="wmd-preview-section preview-content">

<h4 id="5-代码命名规范">5. 代码命名规范</h4>

<p>参考:  <a href="https://google.github.io/styleguide/cppguide.html#Variable_Names%5d" target="_blank">google c++ style guide</a></p></div><div id="wmd-preview-section-1888" class="wmd-preview-section preview-content"></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>